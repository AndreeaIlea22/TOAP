from portality.dao import DomainObject
from portality.lib.seamless import SeamlessMixin
from portality.lib.coerce import COERCE_MAP
from portality.lib import es_data_mapping
from portality.core import app

ANNOTATION_STRUCT = {
    "fields": {
        "id": {"coerce": "unicode"},
        "es_type": {"coerce": "unicode"},
        "created_date": {"coerce": "utcdatetime"},
        "last_updated": {"coerce": "utcdatetime"},
        "application": {"coerce": "unicode"}
    },
    "lists": {
        "annotations": {"contains": "object"}
    },

    "structs": {
        "annotations": {
            "fields": {
                "field": {"coerce": "unicode"},
                "original_value": {"coerce": "unicode"},
                "suggested_value": {"coerce": "unicode"},
                "replaced_value": {"coerce": "unicode"},
                "advice": {"coerce": "unicode"},
                "reference_url": {"coerce": "unicode"}
            }
        }
    }
}

MAPPING_OPTS = {
    "dynamic": None,
    "coerces": app.config["DATAOBJ_TO_MAPPING_DEFAULTS"]
}


class Annotation(SeamlessMixin, DomainObject):
    __type__ = "annotation"

    __SEAMLESS_STRUCT__ = [
        ANNOTATION_STRUCT
    ]

    __SEAMLESS_COERCE__ = COERCE_MAP

    def __init__(self, **kwargs):
        # FIXME: hack, to deal with ES integration layer being improperly abstracted
        if "_source" in kwargs:
            kwargs = kwargs["_source"]
        # FIXME: I have taken this out for the moment, as I'm not sure it's what we should be doing
        # if kwargs:
        #    self.add_autogenerated_fields(**kwargs)
        super(Annotation, self).__init__(raw=kwargs)

    def mappings(self):
        return es_data_mapping.create_mapping(self.__seamless_struct__.raw, MAPPING_OPTS)

    @property
    def data(self):
        return self.__seamless__.data

    @classmethod
    def for_application(cls, app_id):
        q = ApplicationQuery(app_id)
        res = cls.object_query(q.query())
        if len(res) > 0:
            return res[0]
        return None

    @property
    def application(self):
        return self.__seamless__.get_single("application")

    @application.setter
    def application(self, val):
        self.__seamless__.set_with_struct("application", val)

    def add_annotation(self, field=None, original_value=None, suggested_value=None, advice=None, reference_url=None):
        obj = {}
        if field is not None:
            obj["field"] = field
        if original_value is not None:
            obj["original_value"] = original_value
        if suggested_value is not None:
            obj["suggested_value"] = suggested_value
        if advice is not None:
            obj["advice"] = advice
        if reference_url is not None:
            obj["reference_url"] = reference_url

        # ensure we add the annotation only once
        self.__seamless__.delete_from_list("annotations", val=obj)
        self.__seamless__.add_to_list_with_struct("annotations", obj)

    @property
    def annotations(self):
        return self.__seamless__.get_list("annotations")


class ApplicationQuery(object):
    def __init__(self, app_id):
        self._app_id = app_id

    def query(self):
        return {
            "query" : {
                "bool": {
                    "must": [
                        {"term": {"application.exact": self._app_id}}
                    ]
                }
            },
            "size": 1,
            "sort": {
                "created_date": {"order": "desc"}
            }
        }